// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2013.4
// Copyright (C) 2013 Xilinx Inc. All rights reserved.
// 
// ==============================================================


`timescale 1 ns / 1 ps

module prime_urem_32ns_32s_32_35_div
#(parameter
        M       =       32,
        N       =       32,
        W       =       M > N ? M : N
)
(
        input                   clk,
        input                   reset,
        input                   ce,
        input                   start,
        input           [M-1:0] dividend,
        input           [N-1:0] divisor,
        output  wire    [W-1:0] quot,
        output  wire    [W-1:0] remd
);
//------------------------Local signal-------------------
reg             do_start = 0;
reg             ce0      = 0;
reg     [W-1:0] dividend0;
reg     [W-1:0] divisor0;
reg     [W-1:0] dividend_tmp;
reg     [W-1:0] divisor_tmp;
reg     [W-1:0] quot_tmp;
reg     [W-1:0] quot_o;
reg     [W-1:0] remd_tmp;
reg     [W-1:0] remd_o;
wire    [W-1:0] dividend_tmp_mux;
wire    [W-1:0] divisor_tmp_mux;
wire    [W-1:0] quot_tmp_mux;
wire    [W-1:0] remd_tmp_mux;
wire    [W-1:0] comb_tmp;
wire    [W:0]   cal_tmp;
//------------------------Body---------------------------
assign  quot    = (ce0==1'b1)?quot_o:{W{1'b0}};
assign  remd    = (ce0==1'b1)?remd_o:{W{1'b0}};

// ce0
always @ (posedge clk) begin
        if(reset == 1'b1)
            ce0             <=      1'b0;
        else
            ce0             <=      ce;
end

// dividend0, divisor0
always @(posedge clk)
begin
        dividend0       <=      dividend;
        divisor0        <=      divisor;
        do_start        <=      start;
end

// Counter
reg     [W-1:0]     cnt;
wire                sel;
assign  sel    =    (cnt != {W{1'b0}});
always @ (posedge clk) begin
    if(reset == 1'b1) begin
        cnt         <=      {W{1'b0}};
    end
    else begin
        if (cnt != W && (sel || do_start)) begin
            cnt         <=      cnt + 1'b1;
        end
        else if (cnt == W) begin
            cnt         <=      {W{1'b0}};
        end
    end
end

// MUXs
assign  dividend_tmp_mux    =       sel? dividend_tmp:dividend0;
assign  divisor_tmp_mux     =       sel? divisor_tmp:divisor0;
assign  quot_tmp_mux        =       sel? quot_tmp:{W{1'b0}};
assign  remd_tmp_mux        =       sel? remd_tmp:{W{1'b0}};

assign  comb_tmp     =       {remd_tmp_mux[W-2:0], dividend_tmp_mux[W-1]};
assign  cal_tmp      =       {1'b0, comb_tmp} - {1'b0, divisor_tmp_mux};
always @(posedge clk)
begin
    dividend_tmp       <=      {dividend_tmp_mux[W-2:0], 1'b0};
    divisor_tmp        <=      divisor_tmp_mux;
    quot_tmp           <=      {quot_tmp_mux[W-2:0], ~cal_tmp[W]};
    remd_tmp           <=      cal_tmp[W]? comb_tmp : cal_tmp[W-1:0];
end

// Output reg
always @(posedge clk) begin
    if (cnt == W)
    begin
        quot_o      <=       quot_tmp;
        remd_o      <=       remd_tmp;
    end
    else begin
        quot_o      <=       quot_o;
        remd_o      <=       remd_o;
    end
end

endmodule

`timescale 1 ns / 1 ps
module prime_urem_32ns_32s_32_35(
    clk,
    reset,
    ce,
    start,
    din0,
    din1,
    dout);

parameter ID = 32'd1;
parameter NUM_STAGE = 32'd1;
parameter din0_WIDTH = 32'd1;
parameter din1_WIDTH = 32'd1;
parameter dout_WIDTH = 32'd1;
input clk;
input reset;
input ce;
input start;
input[din0_WIDTH - 1:0] din0;
input[din1_WIDTH - 1:0] din1;
output[dout_WIDTH - 1:0] dout;

wire[dout_WIDTH - 1:0] sig_quot;



prime_urem_32ns_32s_32_35_div prime_urem_32ns_32s_32_35_div_U(
    .dividend( din0 ),
    .divisor( din1 ),
    .remd( dout ),
    .quot( sig_quot ),
    .clk( clk ),
    .ce( ce ),
    .reset( reset ),
    .start( start ));

endmodule

