//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void MSP430InstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    268435467U,	// ADC16mi
    570425355U,	// ADC16mm
    268435467U,	// ADC16mr
    285212683U,	// ADC16ri
    603979787U,	// ADC16rm
    285212683U,	// ADC16rr
    268435475U,	// ADC8mi
    570425363U,	// ADC8mm
    268435475U,	// ADC8mr
    285212691U,	// ADC8ri
    603979795U,	// ADC8rm
    285212691U,	// ADC8rr
    268435483U,	// ADD16mi
    570425371U,	// ADD16mm
    268435483U,	// ADD16mr
    285212699U,	// ADD16ri
    603979803U,	// ADD16rm
    805306402U,	// ADD16rm_POST
    285212699U,	// ADD16rr
    268435498U,	// ADD8mi
    570425386U,	// ADD8mm
    268435498U,	// ADD8mr
    285212714U,	// ADD8ri
    603979818U,	// ADD8rm
    805306417U,	// ADD8rm_POST
    285212714U,	// ADD8rr
    57U,	// ADJCALLSTACKDOWN
    75U,	// ADJCALLSTACKUP
    268435547U,	// AND16mi
    570425435U,	// AND16mm
    268435547U,	// AND16mr
    285212763U,	// AND16ri
    603979867U,	// AND16rm
    805306466U,	// AND16rm_POST
    285212763U,	// AND16rr
    268435562U,	// AND8mi
    570425450U,	// AND8mm
    268435562U,	// AND8mr
    285212778U,	// AND8ri
    603979882U,	// AND8rm
    805306481U,	// AND8rm_POST
    285212778U,	// AND8rr
    570425465U,	// BIC16mm
    268435577U,	// BIC16mr
    603979897U,	// BIC16rm
    285212793U,	// BIC16rr
    570425472U,	// BIC8mm
    268435584U,	// BIC8mr
    603979904U,	// BIC8rm
    285212800U,	// BIC8rr
    268435591U,	// BIT16mi
    570425479U,	// BIT16mm
    268435591U,	// BIT16mr
    1073741959U,	// BIT16ri
    1342177415U,	// BIT16rm
    1073741959U,	// BIT16rr
    268435598U,	// BIT8mi
    570425486U,	// BIT8mm
    268435598U,	// BIT8mr
    1073741966U,	// BIT8ri
    1342177422U,	// BIT8rm
    1073741966U,	// BIT8rr
    1711276181U,	// Bi
    1879048345U,	// Bm
    1744830617U,	// Br
    1711276192U,	// CALLi
    2147483808U,	// CALLm
    1711276192U,	// CALLr
    268435622U,	// CMP16mi
    268435622U,	// CMP16mr
    1073741990U,	// CMP16ri
    1342177446U,	// CMP16rm
    1073741990U,	// CMP16rr
    268435629U,	// CMP8mi
    268435629U,	// CMP8mr
    1073741997U,	// CMP8ri
    1342177453U,	// CMP8rm
    1073741997U,	// CMP8rr
    2415919284U,	// JCC
    2684354742U,	// JMP
    268435609U,	// MOV16mi
    570425497U,	// MOV16mm
    268435609U,	// MOV16mr
    1073741977U,	// MOV16ri
    1342177433U,	// MOV16rm
    436207803U,	// MOV16rm_POST
    1073741977U,	// MOV16rr
    268435651U,	// MOV8mi
    570425539U,	// MOV8mm
    268435651U,	// MOV8mr
    1073742019U,	// MOV8ri
    1342177475U,	// MOV8rm
    436207818U,	// MOV8rm_POST
    1073742019U,	// MOV8rr
    1342177475U,	// MOVZX16rm8
    1073742019U,	// MOVZX16rr8
    210U,	// NOP
    268435670U,	// OR16mi
    570425558U,	// OR16mm
    268435670U,	// OR16mr
    285212886U,	// OR16ri
    603979990U,	// OR16rm
    805306589U,	// OR16rm_POST
    285212886U,	// OR16rr
    268435685U,	// OR8mi
    570425573U,	// OR8mm
    268435685U,	// OR8mr
    285212901U,	// OR8ri
    603980005U,	// OR8rm
    805306604U,	// OR8rm_POST
    285212901U,	// OR8rr
    1711276276U,	// POP16r
    1711276283U,	// PUSH16r
    259U,	// RET
    263U,	// RETI
    1711276300U,	// SAR16r1
    1711276307U,	// SAR16r1c
    1711276320U,	// SAR8r1
    1711276327U,	// SAR8r1c
    268435764U,	// SBC16mi
    570425652U,	// SBC16mm
    268435764U,	// SBC16mr
    285212980U,	// SBC16ri
    603980084U,	// SBC16rm
    285212980U,	// SBC16rr
    268435772U,	// SBC8mi
    570425660U,	// SBC8mm
    268435772U,	// SBC8mr
    285212988U,	// SBC8ri
    603980092U,	// SBC8rm
    285212988U,	// SBC8rr
    1711276356U,	// SEXT16r
    1711276361U,	// SHL16r1
    1711276368U,	// SHL8r1
    268435799U,	// SUB16mi
    570425687U,	// SUB16mm
    268435799U,	// SUB16mr
    285213015U,	// SUB16ri
    603980119U,	// SUB16rm
    805306718U,	// SUB16rm_POST
    285213015U,	// SUB16rr
    268435814U,	// SUB8mi
    570425702U,	// SUB8mm
    268435814U,	// SUB8mr
    285213030U,	// SUB8ri
    603980134U,	// SUB8rm
    805306733U,	// SUB8rm_POST
    285213030U,	// SUB8rr
    1711276405U,	// SWPB16r
    379U,	// Select16
    397U,	// Select8
    414U,	// Shl16
    429U,	// Shl8
    443U,	// Sra16
    458U,	// Sra8
    472U,	// Srl16
    487U,	// Srl8
    268435957U,	// XOR16mi
    570425845U,	// XOR16mm
    268435957U,	// XOR16mr
    285213173U,	// XOR16ri
    603980277U,	// XOR16rm
    805306876U,	// XOR16rm_POST
    285213173U,	// XOR16rr
    268435972U,	// XOR8mi
    570425860U,	// XOR8mm
    268435972U,	// XOR8mr
    285213188U,	// XOR8ri
    603980292U,	// XOR8rm
    805306891U,	// XOR8rm_POST
    285213188U,	// XOR8rr
    1073742019U,	// ZEXT16r
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000addc.w\t\000addc.b\t\000add.w\t\000add.w\t@\000add.b\t\000"
    "add.b\t@\000#ADJCALLSTACKDOWN\000#ADJCALLSTACKUP\000and.w\t\000and.w\t@"
    "\000and.b\t\000and.b\t@\000bic.w\t\000bic.b\t\000bit.w\t\000bit.b\t\000"
    "br\t\000mov.w\t\000call\t\000cmp.w\t\000cmp.b\t\000j\000jmp\t\000mov.w\t"
    "@\000mov.b\t\000mov.b\t@\000nop\000bis.w\t\000bis.w\t@\000bis.b\t\000bi"
    "s.b\t@\000pop.w\t\000push.w\t\000ret\000reti\000rra.w\t\000clrc\n\trrc."
    "w\t\000rra.b\t\000clrc\n\trrc.b\t\000subc.w\t\000subc.b\t\000sxt\t\000r"
    "la.w\t\000rla.b\t\000sub.w\t\000sub.w\t@\000sub.b\t\000sub.b\t@\000swpb"
    "\t\000# Select16 PSEUDO\000# Select8 PSEUDO\000# Shl16 PSEUDO\000# Shl8"
    " PSEUDO\000# Sra16 PSEUDO\000# Sra8 PSEUDO\000# Srl16 PSEUDO\000# Srl8 "
    "PSEUDO\000xor.w\t\000xor.w\t@\000xor.b\t\000xor.b\t@\000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 4 bits for 11 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, ADJCALLSTACKDOWN, ADJCALLSTACKUP, NOP, RET, RETI, Select16,...
    return;
    break;
  case 1:
    // ADC16mi, ADC16mr, ADC16ri, ADC16rr, ADC8mi, ADC8mr, ADC8ri, ADC8rr, AD...
    printOperand(MI, 2, O); 
    break;
  case 2:
    // ADC16mm, ADC16rm, ADC8mm, ADC8rm, ADD16mm, ADD16rm, ADD8mm, ADD8rm, AN...
    printSrcMemOperand(MI, 2, O); 
    O << ", "; 
    break;
  case 3:
    // ADD16rm_POST, ADD8rm_POST, AND16rm_POST, AND8rm_POST, OR16rm_POST, OR8...
    printOperand(MI, 3, O); 
    O << "+, "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // BIT16ri, BIT16rr, BIT8ri, BIT8rr, CMP16ri, CMP16rr, CMP8ri, CMP8rr, MO...
    printOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 5:
    // BIT16rm, BIT8rm, CMP16rm, CMP8rm, MOV16rm, MOV8rm, MOVZX16rm8
    printSrcMemOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 6:
    // Bi, Br, CALLi, CALLr, POP16r, PUSH16r, SAR16r1, SAR16r1c, SAR8r1, SAR8...
    printOperand(MI, 0, O); 
    break;
  case 7:
    // Bm
    printSrcMemOperand(MI, 0, O); 
    O << ", pc"; 
    return;
    break;
  case 8:
    // CALLm
    printSrcMemOperand(MI, 0, O, "mem"); 
    return;
    break;
  case 9:
    // JCC
    printCCOperand(MI, 1, O); 
    O << "\t"; 
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  case 10:
    // JMP
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 25) & 7) {
  default:   // unreachable.
  case 0:
    // ADC16mi, ADC16mr, ADC16ri, ADC16rr, ADC8mi, ADC8mr, ADC8ri, ADC8rr, AD...
    O << ", "; 
    break;
  case 1:
    // ADC16mm, ADC8mm, ADD16mm, ADD8mm, AND16mm, AND8mm, BIC16mm, BIC8mm, BI...
    printSrcMemOperand(MI, 0, O); 
    return;
    break;
  case 2:
    // ADC16rm, ADC8rm, ADD16rm, ADD8rm, AND16rm, AND8rm, BIC16rm, BIC8rm, OR...
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // Bi, CALLi, CALLr, POP16r, PUSH16r, SAR16r1, SAR16r1c, SAR8r1, SAR8r1c,...
    return;
    break;
  case 4:
    // Br
    O << ", pc"; 
    return;
    break;
  case 5:
    // MOV16rm_POST, MOV8rm_POST
    O << "+, "; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // ADC16ri, ADC16rr, ADC8ri, ADC8rr, ADD16ri, ADD16rr, ADD8ri, ADD8rr, AN...
    printOperand(MI, 0, O); 
    return;
  } else {
    // ADC16mi, ADC16mr, ADC8mi, ADC8mr, ADD16mi, ADD16mr, ADD8mi, ADD8mr, AN...
    printSrcMemOperand(MI, 0, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *MSP430InstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 33 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 6, 9, 9, 12, 12, 15, 15, 18, 18, 21, 21,
    24, 24, 27, 27, 31, 31, 35, 35, 39, 39, 43, 43, 47, 47,
    51, 51, 54, 54, 0
  };

  const char *AsmStrs =
    "r3\000r3\000r4\000r0\000r5\000r6\000r7\000r8\000r9\000r10\000r11\000r12"
    "\000r13\000r14\000r15\000r1\000r2\000";
  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *MSP430InstPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 186 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 159, 167, 175, 183, 191, 199, 206, 213, 220, 227, 234, 241, 249, 
    257, 265, 273, 281, 294, 302, 309, 316, 323, 330, 337, 349, 356, 373, 
    388, 396, 404, 412, 420, 428, 441, 449, 456, 463, 470, 477, 484, 496, 
    503, 511, 519, 527, 535, 542, 549, 556, 563, 571, 579, 587, 595, 603, 
    611, 618, 625, 632, 639, 646, 653, 656, 659, 662, 668, 674, 680, 688, 
    696, 704, 712, 720, 727, 734, 741, 748, 755, 759, 763, 771, 779, 787, 
    795, 803, 816, 824, 831, 838, 845, 852, 859, 871, 878, 889, 900, 904, 
    911, 918, 925, 932, 939, 951, 958, 964, 970, 976, 982, 988, 999, 1005, 
    1012, 1020, 1024, 1029, 1037, 1046, 1053, 1061, 1069, 1077, 1085, 1093, 1101, 1109, 
    1116, 1123, 1130, 1137, 1144, 1151, 1159, 1167, 1174, 1182, 1190, 1198, 1206, 1214, 
    1227, 1235, 1242, 1249, 1256, 1263, 1270, 1282, 1289, 1297, 1306, 1314, 1320, 1325, 
    1331, 1336, 1342, 1347, 1355, 1363, 1371, 1379, 1387, 1400, 1408, 1415, 1422, 1429, 
    1436, 1443, 1455, 1462, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADC16mi\000ADC16mm\000"
    "ADC16mr\000ADC16ri\000ADC16rm\000ADC16rr\000ADC8mi\000ADC8mm\000ADC8mr\000"
    "ADC8ri\000ADC8rm\000ADC8rr\000ADD16mi\000ADD16mm\000ADD16mr\000ADD16ri\000"
    "ADD16rm\000ADD16rm_POST\000ADD16rr\000ADD8mi\000ADD8mm\000ADD8mr\000ADD"
    "8ri\000ADD8rm\000ADD8rm_POST\000ADD8rr\000ADJCALLSTACKDOWN\000ADJCALLST"
    "ACKUP\000AND16mi\000AND16mm\000AND16mr\000AND16ri\000AND16rm\000AND16rm"
    "_POST\000AND16rr\000AND8mi\000AND8mm\000AND8mr\000AND8ri\000AND8rm\000A"
    "ND8rm_POST\000AND8rr\000BIC16mm\000BIC16mr\000BIC16rm\000BIC16rr\000BIC"
    "8mm\000BIC8mr\000BIC8rm\000BIC8rr\000BIT16mi\000BIT16mm\000BIT16mr\000B"
    "IT16ri\000BIT16rm\000BIT16rr\000BIT8mi\000BIT8mm\000BIT8mr\000BIT8ri\000"
    "BIT8rm\000BIT8rr\000Bi\000Bm\000Br\000CALLi\000CALLm\000CALLr\000CMP16m"
    "i\000CMP16mr\000CMP16ri\000CMP16rm\000CMP16rr\000CMP8mi\000CMP8mr\000CM"
    "P8ri\000CMP8rm\000CMP8rr\000JCC\000JMP\000MOV16mi\000MOV16mm\000MOV16mr"
    "\000MOV16ri\000MOV16rm\000MOV16rm_POST\000MOV16rr\000MOV8mi\000MOV8mm\000"
    "MOV8mr\000MOV8ri\000MOV8rm\000MOV8rm_POST\000MOV8rr\000MOVZX16rm8\000MO"
    "VZX16rr8\000NOP\000OR16mi\000OR16mm\000OR16mr\000OR16ri\000OR16rm\000OR"
    "16rm_POST\000OR16rr\000OR8mi\000OR8mm\000OR8mr\000OR8ri\000OR8rm\000OR8"
    "rm_POST\000OR8rr\000POP16r\000PUSH16r\000RET\000RETI\000SAR16r1\000SAR1"
    "6r1c\000SAR8r1\000SAR8r1c\000SBC16mi\000SBC16mm\000SBC16mr\000SBC16ri\000"
    "SBC16rm\000SBC16rr\000SBC8mi\000SBC8mm\000SBC8mr\000SBC8ri\000SBC8rm\000"
    "SBC8rr\000SEXT16r\000SHL16r1\000SHL8r1\000SUB16mi\000SUB16mm\000SUB16mr"
    "\000SUB16ri\000SUB16rm\000SUB16rm_POST\000SUB16rr\000SUB8mi\000SUB8mm\000"
    "SUB8mr\000SUB8ri\000SUB8rm\000SUB8rm_POST\000SUB8rr\000SWPB16r\000Selec"
    "t16\000Select8\000Shl16\000Shl8\000Sra16\000Sra8\000Srl16\000Srl8\000XO"
    "R16mi\000XOR16mm\000XOR16mr\000XOR16ri\000XOR16rm\000XOR16rm_POST\000XO"
    "R16rr\000XOR8mi\000XOR8mm\000XOR8mr\000XOR8ri\000XOR8rm\000XOR8rm_POST\000"
    "XOR8rr\000ZEXT16r\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_GR16,
    RC_GR8
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_GR16:
    switch (Reg) {
    default: break;
    case MSP430::R12W:
    case MSP430::R13W:
    case MSP430::R14W:
    case MSP430::R15W:
    case MSP430::R11W:
    case MSP430::R10W:
    case MSP430::R9W:
    case MSP430::R8W:
    case MSP430::R7W:
    case MSP430::R6W:
    case MSP430::R5W:
    case MSP430::FPW:
    case MSP430::PCW:
    case MSP430::SPW:
    case MSP430::SRW:
    case MSP430::CGW:
      return true;
    }
    break;
  case RC_GR8:
    switch (Reg) {
    default: break;
    case MSP430::R12B:
    case MSP430::R13B:
    case MSP430::R14B:
    case MSP430::R15B:
    case MSP430::R11B:
    case MSP430::R10B:
    case MSP430::R9B:
    case MSP430::R8B:
    case MSP430::R7B:
    case MSP430::R6B:
    case MSP430::R5B:
    case MSP430::FPB:
    case MSP430::PCB:
    case MSP430::SPB:
    case MSP430::SRB:
    case MSP430::CGB:
      return true;
    }
    break;
  }

  return false;
}

bool MSP430InstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
